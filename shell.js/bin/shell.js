// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var AnimationLayer, Root, Surfaces, TaskQueue, calcOffset, clearCanvas, composeElements, copy, copyCanvas, difference, drawImage, drawSurface, error, execmap, extend, has, isArray, isCanvas, isFunction, isHit, isImage, isNumber, isObject, isPrimitive, loadImage, overwrite, transImage, unique,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  isPrimitive = function(a) {
    switch (typeof a) {
      case "number":
        return true;
      case "string":
        return true;
      case "boolean":
        return true;
      case "undefined":
        return true;
      case "null":
        return true;
      default:
        return false;
    }
  };

  isNumber = function(num) {
    return isFinite(Number(num));
  };

  isObject = function(obj) {
    return Object.prototype.toString.apply(obj) === "[object Object]";
  };

  isArray = function(ary) {
    return Array.isArray(ary);
  };

  isFunction = function(fn) {
    return Object.prototype.toString.apply(fn) === "[object Function]";
  };

  isImage = function(img) {
    return Object.prototype.toString.apply(img) === "[object HTMLImageElement]";
  };

  isCanvas = function(cnv) {
    return Object.prototype.toString.apply(cnv) === "[object HTMLCanvasElement]";
  };

  extend = function(a, b) {
    var key, val;
    for (key in b) {
      val = b[key];
      if (b.hasOwnProperty(key)) {
        a[key] = val;
      }
    }
    return a;
  };

  overwrite = function(a, b) {
    var key, val;
    for (key in b) {
      val = b[key];
      if (b.hasOwnProperty(key)) {
        if (isPrimitive(val) || (a[key] == null)) {
          a[key] = val;
        } else {
          overwrite(a[key], val);
        }
      }
    }
    return a;
  };

  copy = function(a) {
    var key, o, val;
    if (isPrimitive(a)) {
      return a;
    } else if (Array.isArray(a)) {
      o = [];
    } else if (a.constructor != null) {
      o = Object.create(a.constructor.prototype);
    } else {
      o = {};
    }
    for (key in a) {
      val = a[key];
      if (a.hasOwnProperty(key)) {
        if (isPrimitive(val)) {
          o[key] = val;
        } else {
          o[key] = copy(val);
        }
      }
    }
    return o;
  };

  has = function(a, b) {
    var key, val;
    for (key in a) {
      val = a[key];
      if (val === b) {
        return true;
      }
    }
    return false;
  };

  unique = function(a) {
    var rslts, seens, val, _i, _len;
    rslts = [];
    seens = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      val = a[_i];
      if (has(seens, val)) {
        break;
      }
      seens.push(val);
      rslts.push(val);
    }
    return rslts;
  };

  difference = function(a, b) {
    return a.filter(function(val) {
      return !has(b, val);
    });
  };

  error = function(e) {
    console.error(e);
    throw e;
  };

  Root = (function() {
    function Root() {
      this.type = /function\s?([^\(]+)/.exec(this.constructor.toString())[1];
    }

    Root.prototype.destructor = function() {
      var key;
      for (key in this) {
        if (this.hasOwnProperty(key)) {
          this[key] = null;
        }
      }
      return void 0;
    };

    Root.prototype.copy = function() {
      return copy(this);
    };

    Root.prototype.extend = function(a) {
      return extend(this, a);
    };

    Root.prototype.log = function() {
      console.log(this);
      return this;
    };

    Root.prototype.dir = function() {
      console.dir(this);
      return this;
    };

    Root.prototype["do"] = function(fn) {
      return fn.call(this);
    };

    return Root;

  })();

  execmap = function(reg, str, fn) {
    var ary, matches;
    ary = [];
    while (true) {
      matches = reg.exec(str);
      if (matches == null) {
        break;
      }
      ary.push(fn(matches));
    }
    return ary;
  };

  loadImage = function(src, cb) {
    var img;
    img = new Image;
    img.onerror = error;
    img.onload = cb;
    return img.src = src;
  };

  transImage = function(img) {
    var b, cnv, ctx, data, g, i, imgdata, r, v, _i, _len, _ref;
    cnv = copyCanvas(img);
    ctx = cnv.getContext("2d");
    imgdata = ctx.getImageData(0, 0, img.width, img.height);
    data = imgdata.data;
    _ref = [data[0], data[1], data[2]], r = _ref[0], g = _ref[1], b = _ref[2];
    for (i = _i = 0, _len = data.length; _i < _len; i = _i += 4) {
      v = data[i];
      if (r === data[i] && g === data[i + 1] && b === data[i + 2]) {
        data[i + 3] = 0;
      }
    }
    ctx.putImageData(imgdata, 0, 0);
    return cnv;
  };

  copyCanvas = function(img) {
    var cnv, ctx;
    cnv = document.createElement("canvas");
    ctx = cnv.getContext("2d");
    cnv.width = img.width;
    cnv.height = img.height;
    ctx.drawImage(img, 0, 0);
    return cnv;
  };

  drawImage = function(a, b, x, y, cmp) {
    var ctx;
    ctx = a.getContext("2d");
    ctx.drawImage(b, x, y);
    return a;
  };

  clearCanvas = function(cnv) {
    cnv.width = cnv.width;
    return cnv;
  };

  drawSurface = function(a, b) {
    if (a.parentNode != null) {
      a.parentNode.width = b.width;
      a.parentNode.height = b.height;
    }
    a.width = b.width;
    a.height = b.height;
    return drawImage(a, b, 0, 0);
  };

  composeElements = function(target, ary) {
    ary.forEach(function(_arg) {
      var cmp, cnv, x, y;
      cnv = _arg.cnv, x = _arg.x, y = _arg.y, cmp = _arg.cmp;
      if (target.width === 0) {
        target.width = cnv.width;
        target.height = cnv.height;
      }
      return drawImage(target, cnv, x, y, cmp);
    });
    return target;
  };

  isHit = function(target, x, y) {
    var ctx, imgdata;
    ctx = target.getContext("2d");
    imgdata = ctx.getImageData(0, 0, x, y);
    return imgdata.data[imgdata.data.length - 1] !== 0;
  };

  calcOffset = function(e) {
    return {
      x: e.offsetX || e.layerX,
      y: e.offsetY || e.layerY
    };
  };

  TaskQueue = (function() {
    function TaskQueue() {
      this.queue = [];
    }

    TaskQueue.prototype.push = function(fn) {
      this.queue.push(fn);
      return this;
    };

    TaskQueue.prototype.run = function(rslt, cb) {
      var next,
        _this = this;
      next = function(rslt) {
        if (_this.queue.length === 0) {
          cb(rslt);
        } else {
          _this.queue.shift()(rslt, next);
        }
        return void 0;
      };
      next(rslt);
      return void 0;
    };

    return TaskQueue;

  })();

  this.Shell = (function(_super) {
    var composeBaseSurfaces, loadBaseSurface, loadBaseSurfaces, loadElement, loadElements, loadSurfaces;

    __extends(Shell, _super);

    function Shell(nar, id, cb) {
      var shell,
        _this = this;
      this.nar = nar;
      this.id = id;
      Shell.__super__.constructor.apply(this, arguments);
      shell = this.nar.shell[this.id];
      loadSurfaces(shell, function(surfaces) {
        return loadBaseSurfaces(shell, surfaces, function(surfaces) {
          return composeBaseSurfaces(shell, surfaces, function(surfaces) {
            _this.surfaces = surfaces;
            return cb(_this);
          });
        });
      });
    }

    loadSurfaces = function(shell, cb) {
      shell["surfaces.txt"].load(function(text) {
        return cb(new Surfaces(text));
      });
      return void 0;
    };

    loadBaseSurfaces = function(shell, surfaces, cb) {
      var file, filename, que;
      que = new TaskQueue();
      for (filename in shell) {
        file = shell[filename];
        if (/surface(\d+)\.png/.test(filename)) {
          (function(file) {
            return que.push(function(surfaces, next) {
              return loadBaseSurface(shell, surfaces, file, function(surfaces) {
                return next(surfaces);
              });
            });
          })(file);
        }
      }
      que.run(surfaces, function(surfaces) {
        return cb(surfaces);
      });
      return void 0;
    };

    loadBaseSurface = function(shell, surfaces, file, cb) {
      var id, srf, _base;
      console.log("unzipping " + file.filename);
      id = Number(/surface(\d+)\.png/.exec(file.filename)[1]);
      srf = (_base = surfaces.surface)[id] != null ? (_base = surfaces.surface)[id] : _base[id] = {};
      file.load(function(img) {
        srf.base = transImage(img);
        return cb(surfaces);
      });
      return void 0;
    };

    composeBaseSurfaces = function(shell, surfaces, cb) {
      var id, que, srf, _fn, _ref;
      que = new TaskQueue();
      _ref = surfaces.surface;
      _fn = function(srf) {
        return que.push(function(surfaces, next) {
          return loadElements(shell, srf, function(elms) {
            if (srf.base == null) {
              srf.base = copyCanvas(new Image());
            }
            srf.base = composeElements(srf.base, elms);
            return next(surfaces);
          });
        });
      };
      for (id in _ref) {
        srf = _ref[id];
        _fn(srf);
      }
      return que.run(surfaces, function(surfaces) {
        return cb(surfaces);
      });
    };

    loadElements = function(shell, srf, cb) {
      var elm, n, que, _fn, _ref;
      que = new TaskQueue();
      _ref = srf.elements;
      _fn = function(elm) {
        return que.push(function(elms, next) {
          return loadElement(shell, elm, function(elm) {
            elms.push(elm);
            return next(elms);
          });
        });
      };
      for (n in _ref) {
        elm = _ref[n];
        _fn(elm);
      }
      que.run([], function(elms) {
        return cb(elms);
      });
      return void 0;
    };

    loadElement = function(shell, elm, cb) {
      console.log("unzipping " + elm.src);
      shell[elm.src].load(function(img) {
        try {
          return cb({
            cnv: transImage(img),
            x: elm.x,
            y: elm.y,
            cmp: elm.compositeOperation
          });
        } catch (_error) {
          debugger;
        }
      });
      return void 0;
    };

    return Shell;

  })(Root);

  Surfaces = (function(_super) {
    var commentout, compatibleBody, compatibleHead, parseAnimations, parseBody, parseCollisions, parseElements, parseHead, parsePatterns, root, space;

    __extends(Surfaces, _super);

    function Surfaces(text) {
      Surfaces.__super__.constructor.apply(this, arguments);
      extend(this, root(text));
    }

    commentout = function(text) {
      execmap(/(?:(?:^|\s)\/\/.*)$|^\s+?$/g, text, function(_arg) {
        var match;
        match = _arg[0];
        return text = text.replace(match, "");
      });
      return text;
    };

    space = function(text) {
      return text.split(" ").join("").split("\t").join("");
    };

    root = function(text) {
      var apnds, defs, n, srf, _text;
      defs = {};
      apnds = {};
      _text = commentout(space(text));
      execmap(/([^\{\}]+)\{([^\{\}]+)\}/g, _text, function(_arg) {
        var body, head, isApnd, n, _, _i, _len, _ref, _results;
        _ = _arg[0], head = _arg[1], body = _arg[2];
        if (/surface/.test(head)) {
          isApnd = /surface\.append/.test(head);
          _ref = parseHead(compatibleHead(head));
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            if (isApnd) {
              if (apnds[n] == null) {
                apnds[n] = {};
              }
              _results.push(overwrite(apnds[n], parseBody(compatibleBody(body))));
            } else {
              if (defs[n] == null) {
                defs[n] = {};
              }
              _results.push(overwrite(defs[n], parseBody(compatibleBody(body))));
            }
          }
          return _results;
        }
      });
      for (n in apnds) {
        srf = apnds[n];
        overwrite(defs[n], srf);
      }
      return {
        surface: defs
      };
    };

    compatibleHead = function(text) {
      execmap(/\,surface(\d+)/g, text, function(_arg) {
        var match, num;
        match = _arg[0], num = _arg[1];
        return text = text.replace(match, "," + num);
      });
      execmap(/sakura/g, text, function(_arg) {
        var match;
        match = _arg[0];
        return text = text.replace(match, "char0");
      });
      execmap(/kero/g, text, function(_arg) {
        var match;
        match = _arg[0];
        return text = text.replace(match, "char1");
      });
      return text;
    };

    compatibleBody = function(text) {
      execmap(/(\d+)interval\,(.+)/g, text, function(_arg) {
        var animId, match, timing;
        match = _arg[0], animId = _arg[1], timing = _arg[2];
        return text = text.replace(match, ("animation" + animId) + ".interval," + ("" + timing));
      });
      execmap(/(\d+)pattern(\d+)\,(\-?\d+)\,(\d+)\,(\w+)(?:\,(\-?\d+)\,(\-?\d+))?/g, text, function(_arg) {
        var anmId, layer, match, ptnId, srfId, wait, x, y;
        match = _arg[0], anmId = _arg[1], ptnId = _arg[2], srfId = _arg[3], wait = _arg[4], layer = _arg[5], x = _arg[6], y = _arg[7];
        return text = text.replace(match, ("animation" + anmId) + (".pattern" + ptnId + ",") + ("" + layer + ",") + ("" + srfId + ",") + ("" + wait + ",") + ("" + (x || 0) + ",") + ("" + (y || 0)));
      });
      return text;
    };

    parseHead = function(head) {
      var aplys, rjcts;
      head = head.replace(/surface/g, "");
      rjcts = [];
      aplys = [];
      execmap(/(\!)?(\d+)(?:\-(\d+))?\,?/g, head, function(_arg) {
        var begin, end, isRjct, match, nums, _begin, _end, _i, _results;
        match = _arg[0], isRjct = _arg[1], begin = _arg[2], end = _arg[3];
        _begin = Number(begin);
        _end = Number(end);
        nums = isFinite(_end) ? (function() {
          _results = [];
          for (var _i = _begin; _begin <= _end ? _i <= _end : _i >= _end; _begin <= _end ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this) : [_begin];
        if (isRjct != null) {
          return rjcts = rjcts.concat(nums);
        } else {
          return aplys = aplys.concat(nums);
        }
      });
      return difference(unique(aplys), unique(rjcts));
    };

    parseBody = function(body) {
      return {
        collisions: parseCollisions(body),
        elements: parseElements(body),
        animations: parseAnimations(body)
      };
    };

    parseCollisions = function(body) {
      var hash;
      hash = {};
      execmap(/collision(\d+)\,(\-?\d+)\,(\-?\d+)\,(\-?\d+)\,(\-?\d+)\,(\w+)/g, body, function(_arg) {
        var beginX, beginY, endX, endY, id, match, n;
        match = _arg[0], n = _arg[1], beginX = _arg[2], beginY = _arg[3], endX = _arg[4], endY = _arg[5], id = _arg[6];
        return hash[Number(n)] = {
          x: Number(beginX),
          y: Number(beginY),
          width: Number(endX) - Number(beginX),
          height: Number(endY) - Number(beginY),
          name: id
        };
      });
      return hash;
    };

    parseElements = function(body) {
      var hash;
      hash = {};
      execmap(/element(\d+)\,(\w+)\,([\w\.]+)(?:\,(\-?\d+)\,(\-?\d+))?/g, body, function(_arg) {
        var layer, match, n, src, x, y;
        match = _arg[0], n = _arg[1], layer = _arg[2], src = _arg[3], x = _arg[4], y = _arg[5];
        return hash[Number(n)] = {
          compositeOperation: layer,
          src: src,
          x: Number(x || 0),
          y: Number(y || 0)
        };
      });
      return hash;
    };

    parseAnimations = function(body) {
      var animNBodies, hash, i, rslts;
      if (body == null) {
        return {};
      }
      animNBodies = {};
      execmap(/animation(\d+)\.([^\r\n]+)/g, body, function(_arg) {
        var match, n, num, str;
        match = _arg[0], num = _arg[1], str = _arg[2];
        n = Number(num);
        return animNBodies[n] = (animNBodies[n] || "") + "\r\n" + str;
      });
      hash = {};
      for (i in animNBodies) {
        body = animNBodies[i];
        rslts = /interval\,(.+)/.exec(body);
        if (rslts != null) {
          hash[i] = {
            interval: rslts[1],
            patterns: parsePatterns(body)
          };
        }
      }
      return hash;
    };

    parsePatterns = function(body) {
      var hash;
      hash = {};
      execmap(/pattern(\d+)\,(\w+)\,(\-?\d+)\,(\d+)(?:\-(\d+))?(?:\,([\-|\+]?\d+)\,([\-|\+]?\d+))?/g, body, function(_arg) {
        var layer, maxWait, minWait, n, num, x, y, __;
        __ = _arg[0], n = _arg[1], layer = _arg[2], num = _arg[3], minWait = _arg[4], maxWait = _arg[5], x = _arg[6], y = _arg[7];
        hash[n] = {
          compositeOperation: layer,
          surfaceID: Number(num),
          wait: Number(minWait),
          x: Number(x || 0),
          y: Number(y || 0)
        };
        if (maxWait != null) {
          return hash[n].maxWait = Number(maxWait);
        }
      });
      return hash;
    };

    return Surfaces;

  })(Root);

  this.Surface = (function(_super) {
    __extends(Surface, _super);

    function Surface(shell, id, handler, cb) {
      var n, render,
        _this = this;
      this.shell = shell;
      this.id = id;
      Surface.__super__.constructor.apply(this, arguments);
      this.surface = this.shell.surfaces.surface[this.id];
      this.canvas = copyCanvas(this.surface.base);
      this.click = this.createEventListener("OnMouseClick", handler);
      this.canvas.addEventListener("click", this.click);
      this.animationLayers = {};
      for (n in this.surface.animations) {
        this.animationLayers[n] = new AnimationLayer(this, n);
      }
      render = function() {
        if (_this.rendering) {
          _this.draw();
          return requestAnimationFrame(render);
        }
      };
      this.rendering = true;
      this.showFPS = true;
      this.showCollision = false;
      this.old = Date.now();
      requestAnimationFrame(render);
      cb(this);
    }

    Surface.prototype.destructor = function() {
      this.rending = false;
      this.canvas.removeEventListener("click", this.click);
      return Surface.__super__.destructor.apply(this, arguments);
    };

    Surface.prototype.draw = function() {
      var cmp, cnv, collision, ctx, height, layer, n, name, now, past, width, x, y, _ref, _ref1, _ref2;
      now = Date.now();
      past = now - this.old;
      this.fps = 1000 / past | 0;
      clearCanvas(this.canvas);
      drawImage(this.canvas, this.surface.base, 0, 0);
      _ref = this.animationLayers;
      for (n in _ref) {
        layer = _ref[n];
        _ref1 = layer.getFrame(now), x = _ref1.x, y = _ref1.y, cnv = _ref1.cnv, cmp = _ref1.cmp;
        drawImage(this.canvas, cnv, x, y, cmp);
      }
      ctx = this.canvas.getContext("2d");
      if (this.showCollision) {
        ctx.strokeStyle = "rgb(200, 0, 0)";
        _ref2 = this.surface.collisions;
        for (n in _ref2) {
          collision = _ref2[n];
          x = collision.x, y = collision.y, width = collision.width, height = collision.height, name = collision.name;
          ctx.strokeRect(x, y, width, height);
        }
      }
      if (this.showFPS) {
        ctx.font = "18px 'Unknown Font'";
        ctx.fillText(this.fps, 10, 20);
      }
      this.old = now;
      return void 0;
    };

    Surface.prototype.createEventListener = function(id, handler) {
      var _this = this;
      return function(e) {
        var collision, event, height, n, name, offset, width, x, y, _ref, _ref1, _ref2;
        offset = calcOffset(e);
        if (isHit(_this.canvas, offset.x, offset.y)) {
          e.preventDefault();
          e.stopPropagation();
          event = {
            "ID": id,
            "Reference0": offset.x,
            "Reference1": offset.y,
            "Reference2": 0,
            "Reference3": null,
            "Reference4": "",
            "Reference5": 0
          };
          if (id === "OnMouseMove") {
            delete event.Reference5;
          }
          _ref = _this.surface.collisions;
          for (n in _ref) {
            collision = _ref[n];
            x = collision.x, y = collision.y, width = collision.width, height = collision.height, name = collision.name;
            if ((x < (_ref1 = offset.x) && _ref1 < x + width) && (y < (_ref2 = offset.y) && _ref2 < y + height)) {
              event.Reference4 = name;
            }
          }
          handler(event);
        }
        return void 0;
      };
    };

    return Surface;

  })(Root);

  AnimationLayer = (function(_super) {
    var random;

    __extends(AnimationLayer, _super);

    function AnimationLayer(surface, id, handler) {
      this.surface = surface;
      this.id = id;
      this.handler = handler != null ? handler : function() {};
      this.animation = this.surface.surface.animations[this.id];
      this.patterns = this.animation.patterns;
      this.interval = this.getInterval();
      this.playing = false;
      this.none = document.createElement("canvas");
      this.none.width = this.none.height = 1;
      this.frame = this.none;
      this.i = 0;
      this.wait = 0;
      this.count = 0;
    }

    AnimationLayer.prototype.getInterval = function() {
      switch (this.animation.interval) {
        case "sometimes":
          return random(2);
        case "rarely":
          return random(4);
        case "runonce":
          if (this.count === 0) {
            return 0;
          } else {
            return Infinity;
          }
        case "always":
          return 0;
        default:
          return Infinity;
      }
    };

    AnimationLayer.prototype.getFrame = function(now) {
      var id;
      if (this.playing) {
        if (now > this.wait) {
          id = Number(this.patterns[this.i].surfaceID);
          if (id === -1) {
            this.frame = this.none;
          } else {
            this.frame = this.surface.shell.surfaces.surface[id].base;
          }
          this.wait = now + this.patterns[this.i].wait;
          this.i++;
          if (this.patterns[this.i] == null) {
            this.i = 0;
            this.playing = false;
            this.interval = now + this.getInterval();
            this.count++;
            this.handler();
          }
        }
      } else if (now > this.interval) {
        this.playing = true;
      }
      return {
        cnv: this.frame,
        x: this.patterns[this.i].x,
        y: this.patterns[this.i].y,
        cmp: this.patterns[this.i].compositeOperation
      };
    };

    random = function(n) {
      var ms;
      ms = 0;
      while (1 / n < Math.random()) {
        ms++;
      }
      return ms * 1000;
    };

    return AnimationLayer;

  })(Root);

}).call(this);

/*
//@ sourceMappingURL=shell.map
*/
