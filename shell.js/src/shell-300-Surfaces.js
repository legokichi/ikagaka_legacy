// Generated by CoffeeScript 1.6.3
var Surfaces,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Surfaces = (function(_super) {
  var commentout, compatibleBody, compatibleHead, parseAnimations, parseBody, parseCollisions, parseElements, parseHead, parsePatterns, root, space;

  __extends(Surfaces, _super);

  function Surfaces(text) {
    Surfaces.__super__.constructor.apply(this, arguments);
    extend(this, root(text));
  }

  commentout = function(text) {
    execmap(/(?:(?:^|\s)\/\/.*)$|^\s+?$/g, text, function(_arg) {
      var match;
      match = _arg[0];
      return text = text.replace(match, "");
    });
    return text;
  };

  space = function(text) {
    return text.split(" ").join("").split("\t").join("");
  };

  root = function(text) {
    var apnds, defs, n, srf, _text;
    defs = {};
    apnds = {};
    _text = commentout(space(text));
    execmap(/([^\{\}]+)\{([^\{\}]+)\}/g, _text, function(_arg) {
      var body, head, isApnd, n, _, _i, _len, _ref, _results;
      _ = _arg[0], head = _arg[1], body = _arg[2];
      if (/surface/.test(head)) {
        isApnd = /surface\.append/.test(head);
        _ref = parseHead(compatibleHead(head));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (isApnd) {
            if (apnds[n] == null) {
              apnds[n] = {};
            }
            _results.push(overwrite(apnds[n], parseBody(compatibleBody(body))));
          } else {
            if (defs[n] == null) {
              defs[n] = {};
            }
            _results.push(overwrite(defs[n], parseBody(compatibleBody(body))));
          }
        }
        return _results;
      }
    });
    for (n in apnds) {
      srf = apnds[n];
      overwrite(defs[n], srf);
    }
    return {
      surface: defs
    };
  };

  compatibleHead = function(text) {
    execmap(/\,surface(\d+)/g, text, function(_arg) {
      var match, num;
      match = _arg[0], num = _arg[1];
      return text = text.replace(match, "," + num);
    });
    execmap(/sakura/g, text, function(_arg) {
      var match;
      match = _arg[0];
      return text = text.replace(match, "char0");
    });
    execmap(/kero/g, text, function(_arg) {
      var match;
      match = _arg[0];
      return text = text.replace(match, "char1");
    });
    return text;
  };

  compatibleBody = function(text) {
    execmap(/(\d+)interval\,(.+)/g, text, function(_arg) {
      var animId, match, timing;
      match = _arg[0], animId = _arg[1], timing = _arg[2];
      return text = text.replace(match, ("animation" + animId) + ".interval," + ("" + timing));
    });
    execmap(/(\d+)pattern(\d+)\,(\-?\d+)\,(\d+)\,(\w+)(?:\,(\-?\d+)\,(\-?\d+))?/g, text, function(_arg) {
      var anmId, layer, match, ptnId, srfId, wait, x, y;
      match = _arg[0], anmId = _arg[1], ptnId = _arg[2], srfId = _arg[3], wait = _arg[4], layer = _arg[5], x = _arg[6], y = _arg[7];
      return text = text.replace(match, ("animation" + anmId) + (".pattern" + ptnId + ",") + ("" + layer + ",") + ("" + srfId + ",") + ("" + wait + ",") + ("" + (x || 0) + ",") + ("" + (y || 0)));
    });
    return text;
  };

  parseHead = function(head) {
    var aplys, rjcts;
    head = head.replace(/surface/g, "");
    rjcts = [];
    aplys = [];
    execmap(/(\!)?(\d+)(?:\-(\d+))?\,?/g, head, function(_arg) {
      var begin, end, isRjct, match, nums, _begin, _end, _i, _results;
      match = _arg[0], isRjct = _arg[1], begin = _arg[2], end = _arg[3];
      _begin = Number(begin);
      _end = Number(end);
      nums = isFinite(_end) ? (function() {
        _results = [];
        for (var _i = _begin; _begin <= _end ? _i <= _end : _i >= _end; _begin <= _end ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this) : [_begin];
      if (isRjct != null) {
        return rjcts = rjcts.concat(nums);
      } else {
        return aplys = aplys.concat(nums);
      }
    });
    return difference(unique(aplys), unique(rjcts));
  };

  parseBody = function(body) {
    return {
      collisions: parseCollisions(body),
      elements: parseElements(body),
      animations: parseAnimations(body)
    };
  };

  parseCollisions = function(body) {
    var hash;
    hash = {};
    execmap(/collision(\d+)\,(\-?\d+)\,(\-?\d+)\,(\-?\d+)\,(\-?\d+)\,(\w+)/g, body, function(_arg) {
      var beginX, beginY, endX, endY, id, match, n;
      match = _arg[0], n = _arg[1], beginX = _arg[2], beginY = _arg[3], endX = _arg[4], endY = _arg[5], id = _arg[6];
      return hash[Number(n)] = {
        x: Number(beginX),
        y: Number(beginY),
        width: Number(endX) - Number(beginX),
        height: Number(endY) - Number(beginY),
        name: id
      };
    });
    return hash;
  };

  parseElements = function(body) {
    var hash;
    hash = {};
    execmap(/element(\d+)\,(\w+)\,([\w\.]+)(?:\,(\-?\d+)\,(\-?\d+))?/g, body, function(_arg) {
      var layer, match, n, src, x, y;
      match = _arg[0], n = _arg[1], layer = _arg[2], src = _arg[3], x = _arg[4], y = _arg[5];
      return hash[Number(n)] = {
        compositeOperation: layer,
        src: src,
        x: Number(x || 0),
        y: Number(y || 0)
      };
    });
    return hash;
  };

  parseAnimations = function(body) {
    var animNBodies, hash, i, rslts;
    if (body == null) {
      return {};
    }
    animNBodies = {};
    execmap(/animation(\d+)\.([^\r\n]+)/g, body, function(_arg) {
      var match, n, num, str;
      match = _arg[0], num = _arg[1], str = _arg[2];
      n = Number(num);
      return animNBodies[n] = (animNBodies[n] || "") + "\r\n" + str;
    });
    hash = {};
    for (i in animNBodies) {
      body = animNBodies[i];
      rslts = /interval\,(.+)/.exec(body);
      if (rslts != null) {
        hash[i] = {
          interval: rslts[1],
          patterns: parsePatterns(body)
        };
      }
    }
    return hash;
  };

  parsePatterns = function(body) {
    var hash;
    hash = {};
    execmap(/pattern(\d+)\,(\w+)\,(\-?\d+)\,(\d+)(?:\-(\d+))?(?:\,([\-|\+]?\d+)\,([\-|\+]?\d+))?/g, body, function(_arg) {
      var layer, maxWait, minWait, n, num, x, y, __;
      __ = _arg[0], n = _arg[1], layer = _arg[2], num = _arg[3], minWait = _arg[4], maxWait = _arg[5], x = _arg[6], y = _arg[7];
      hash[n] = {
        compositeOperation: layer,
        surfaceID: Number(num),
        wait: Number(minWait),
        x: Number(x || 0),
        y: Number(y || 0)
      };
      if (maxWait != null) {
        return hash[n].maxWait = Number(maxWait);
      }
    });
    return hash;
  };

  return Surfaces;

})(Root);
